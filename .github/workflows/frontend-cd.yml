name: CD - Deploy Frontend to AKS

on:
  workflow_call:
    inputs:
      product_api_ip:   { required: false, type: string }
      order_api_ip:     { required: false, type: string }
      customer_api_ip:  { required: false, type: string }
      k8s_namespace:    { required: false, type: string }
      aks_cluster_name: { required: false, type: string }
      aks_resource_group: { required: false, type: string }
      acr_login_server: { required: false, type: string }
      frontend_tag:     { required: false, type: string }
  workflow_dispatch: {}  # You can still run it manually; it will use secrets if inputs omitted.

permissions:
  contents: read

env:
  FRONTEND_DEPLOY:    frontend-w05-aks
  FRONTEND_CONTAINER: frontend-container

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    environment: Production
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Resolve inputs (fallback to secrets)
        shell: bash
        env:
          IN_NS:          ${{ inputs.k8s_namespace }}
          IN_AKS_RG:      ${{ inputs.aks_resource_group }}
          IN_AKS_NAME:    ${{ inputs.aks_cluster_name }}
          IN_ACR:         ${{ inputs.acr_login_server }}
          IN_TAG:         ${{ inputs.frontend_tag }}
          SEC_AKS_RG:     ${{ secrets.AKS_RESOURCE_GROUP }}
          SEC_AKS_NAME:   ${{ secrets.AKS_CLUSTER_NAME }}
          SEC_ACR:        ${{ secrets.AZURE_CONTAINER_REGISTRY }}
          IN_PROD_URL:    ${{ inputs.product_api_ip }}
          IN_ORDER_URL:   ${{ inputs.order_api_ip }}
          IN_CUST_URL:    ${{ inputs.customer_api_ip }}
        run: |
          set -Eeuo pipefail
          NS="${IN_NS:-dev}"
          echo "K8S_NAMESPACE_RESOLVED=$NS" >> $GITHUB_ENV

          AKS_RG="${IN_AKS_RG:-$SEC_AKS_RG}"
          AKS_NAME="${IN_AKS_NAME:-$SEC_AKS_NAME}"
          if [[ -z "$AKS_RG" || -z "$AKS_NAME" ]]; then
            echo "ERROR: aks_resource_group/aks_cluster_name not provided and secrets missing"; exit 1
          fi
          echo "AKS_RESOURCE_GROUP=$AKS_RG" >> $GITHUB_ENV
          echo "AKS_CLUSTER_NAME=$AKS_NAME" >> $GITHUB_ENV

          ACR_LOGIN_SERVER="${IN_ACR:-$SEC_ACR}"
          if [[ -z "$ACR_LOGIN_SERVER" ]]; then
            echo "ERROR: acr_login_server not provided and AZURE_CONTAINER_REGISTRY secret missing"; exit 1
          fi
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          ACR_NAME="${ACR_LOGIN_SERVER%%.*}"
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV

          TAG="${IN_TAG:-latest}"
          echo "FRONTEND_TAG=$TAG" >> $GITHUB_ENV

          # optional backend URLs (if orchestrator passed them)
          [ -n "$IN_PROD_URL" ]  && echo "PRODUCT_URL=$IN_PROD_URL"   >> $GITHUB_ENV
          [ -n "$IN_ORDER_URL" ] && echo "ORDER_URL=$IN_ORDER_URL"     >> $GITHUB_ENV
          [ -n "$IN_CUST_URL" ]  && echo "CUSTOMER_URL=$IN_CUST_URL"   >> $GITHUB_ENV

      # Ensure AKS can pull from ACR (and fallback secret)
      - name: Attach ACR to AKS (idempotent)
        run: az aks update -g "$AKS_RESOURCE_GROUP" -n "$AKS_CLUSTER_NAME" --attach-acr "$ACR_NAME" || true

      - name: Set AKS context
        run: |
          az aks get-credentials -g "$AKS_RESOURCE_GROUP" -n "$AKS_CLUSTER_NAME" --overwrite-existing
          kubectl cluster-info

      - name: Ensure namespace exists
        run: kubectl get ns "$K8S_NAMESPACE_RESOLVED" >/dev/null 2>&1 || kubectl create ns "$K8S_NAMESPACE_RESOLVED"

      - name: Create/patch ACR imagePullSecret (fallback)
        shell: bash
        run: |
          set -Eeuo pipefail
          NS="$K8S_NAMESPACE_RESOLVED"
          az acr update -n "$ACR_NAME" --admin-enabled true >/dev/null
          ACR_USER=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
          ACR_PASS=$(az acr credential show -n "$ACR_NAME" --query 'passwords[0].value' -o tsv)
          kubectl -n "$NS" delete secret acr-pull --ignore-not-found
          kubectl -n "$NS" create secret docker-registry acr-pull \
            --docker-server="$ACR_LOGIN_SERVER" \
            --docker-username="$ACR_USER" \
            --docker-password="$ACR_PASS"
          kubectl -n "$NS" patch serviceaccount default -p '{"imagePullSecrets":[{"name":"acr-pull"}]}' || true

      # Inject backend URLs if provided
      - name: Inject backend URLs into main.js (if provided)
        if: ${{ env.PRODUCT_URL != '' && env.ORDER_URL != '' && env.CUSTOMER_URL != '' }}
        run: |
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g" frontend/main.js

      - name: Apply manifests
        run: kubectl apply -n "$K8S_NAMESPACE_RESOLVED" -f k8s/frontend.yaml

      - name: Set image and rollout
        run: |
          kubectl -n "$K8S_NAMESPACE_RESOLVED" set image deploy/${{ env.FRONTEND_DEPLOY }} \
            ${{ env.FRONTEND_CONTAINER }}="${ACR_LOGIN_SERVER}/frontend:${FRONTEND_TAG}"
          kubectl -n "$K8S_NAMESPACE_RESOLVED" rollout restart deploy/${{ env.FRONTEND_DEPLOY }}
          kubectl -n "$K8S_NAMESPACE_RESOLVED" rollout status  deploy/${{ env.FRONTEND_DEPLOY }} --timeout=300s

      - name: Logout Azure
        if: always()
        run: az logout
