name: CD - Deploy Frontend to AKS

on:
  workflow_call:
    inputs:
      k8s_namespace:
        required: true
        type: string
      product_api_ip:
        required: false
        type: string
      order_api_ip:
        required: false
        type: string
      customer_api_ip:
        required: false
        type: string
      aks_cluster_name:
        required: false
        type: string
      aks_resource_group:
        required: false
        type: string
      acr_login_server:
        required: false
        type: string
      frontend_tag:
        required: false
        type: string
  workflow_dispatch: {}

permissions:
  contents: read

env:
  K8S_NAMESPACE_DEFAULT: dev
  FRONTEND_DEPLOY:   frontend-w05-aks
  FRONTEND_CONTAINER: frontend-container

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    environment: Production

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Resolve inputs (namespace, AKS, ACR, tag, API URLs)
        id: resolve
        shell: bash
        env:
          IN_NS:        ${{ inputs.k8s_namespace }}
          IN_AKS_RG:    ${{ inputs.aks_resource_group }}
          IN_AKS_NAME:  ${{ inputs.aks_cluster_name }}
          IN_ACR:       ${{ inputs.acr_login_server }}
          IN_TAG:       ${{ inputs.frontend_tag }}
          IN_PROD_URL:  ${{ inputs.product_api_ip }}
          IN_ORDER_URL: ${{ inputs.order_api_ip }}
          IN_CUST_URL:  ${{ inputs.customer_api_ip }}
          SEC_AKS_RG:   ${{ secrets.AKS_RESOURCE_GROUP }}
          SEC_AKS_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
          SEC_ACR:      ${{ secrets.AZURE_CONTAINER_REGISTRY }}
        run: |
          set -Eeuo pipefail

          # Namespace
          NS="${IN_NS:-$K8S_NAMESPACE_DEFAULT}"
          echo "K8S_NAMESPACE_RESOLVED=$NS" >> $GITHUB_ENV

          # AKS RG/Name: inputs -> secrets -> auto-detect
          AKS_RG="${IN_AKS_RG:-$SEC_AKS_RG}"
          AKS_NAME="${IN_AKS_NAME:-$SEC_AKS_NAME}"
          if [[ -z "$AKS_RG" || -z "$AKS_NAME" ]]; then
            echo "AKS RG/Name not provided; attempting auto-detect…" >&2
            if [[ -n "$SEC_AKS_RG" ]]; then
              AKS_NAME=$(az aks list -g "$SEC_AKS_RG" --query '[0].name' -o tsv 2>/dev/null || true)
              AKS_RG="$SEC_AKS_RG"
            fi
            if [[ -z "$AKS_NAME" ]]; then
              AKS_NAME=$(az aks list --query '[0].name' -o tsv 2>/dev/null || true)
              if [[ -n "$AKS_NAME" ]]; then
                AKS_RG=$(az aks show -n "$AKS_NAME" --query resourceGroup -o tsv)
              fi
            fi
          fi
          if [[ -z "$AKS_RG" || -z "$AKS_NAME" ]]; then
            echo "ERROR: aks_resource_group/aks_cluster_name not provided and could not auto-detect." >&2
            exit 1
          fi
          echo "AKS_RESOURCE_GROUP=$AKS_RG" >> $GITHUB_ENV
          echo "AKS_CLUSTER_NAME=$AKS_NAME" >> $GITHUB_ENV

          # ACR login server: inputs -> secret, then resolve ACR name via Azure
          ACR_LOGIN_SERVER="${IN_ACR:-$SEC_ACR}"
          if [[ -z "$ACR_LOGIN_SERVER" ]]; then
            echo "ERROR: acr_login_server not provided and AZURE_CONTAINER_REGISTRY secret missing" >&2
            exit 1
          fi
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          ACR_NAME=$(az acr list --query "[?loginServer=='${ACR_LOGIN_SERVER}'].name | [0]" -o tsv 2>/dev/null || true)
          if [[ -z "$ACR_NAME" ]]; then
            ACR_NAME="${ACR_LOGIN_SERVER%%.*}"
          fi
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV

          # Tag (default latest)
          TAG="${IN_TAG:-latest}"
          echo "FRONTEND_TAG=$TAG" >> $GITHUB_ENV

          # Optional backend URLs → only used if provided
          [[ -n "${IN_PROD_URL}"  ]] && echo "PRODUCT_URL=$IN_PROD_URL"   >> $GITHUB_ENV
          [[ -n "${IN_ORDER_URL}" ]] && echo "ORDER_URL=$IN_ORDER_URL"    >> $GITHUB_ENV
          [[ -n "${IN_CUST_URL}"  ]] && echo "CUSTOMER_URL=$IN_CUST_URL"  >> $GITHUB_ENV

          echo "Resolved:"
          echo "  Namespace  = $NS"
          echo "  AKS        = $AKS_RG / $AKS_NAME"
          echo "  ACR        = $ACR_LOGIN_SERVER (name: $ACR_NAME)"
          echo "  Tag        = $TAG"
          echo "  ProductURL = ${IN_PROD_URL:-<unchanged>}"
          echo "  OrderURL   = ${IN_ORDER_URL:-<unchanged>}"
          echo "  CustomerURL= ${IN_CUST_URL:-<unchanged>}"

      - name: Set AKS context
        shell: bash
        run: |
          az aks get-credentials -g "$AKS_RESOURCE_GROUP" -n "$AKS_CLUSTER_NAME" --overwrite-existing
          kubectl cluster-info

      - name: Attach ACR to AKS (idempotent)
        shell: bash
        run: |
          set -Eeuo pipefail
          az aks update -g "$AKS_RESOURCE_GROUP" -n "$AKS_CLUSTER_NAME" --attach-acr "$ACR_NAME" || true

      - name: Ensure namespace exists
        shell: bash
        run: |
          kubectl get ns "$K8S_NAMESPACE_RESOLVED" >/dev/null 2>&1 || kubectl create ns "$K8S_NAMESPACE_RESOLVED"

      - name: Create/patch imagePullSecret (fallback; best-effort)
        shell: bash
        run: |
          set -Eeuo pipefail
          NS="$K8S_NAMESPACE_RESOLVED"
          # Best effort: admin creds may be disabled by policy; ignore failures
          if az acr update -n "$ACR_NAME" --admin-enabled true >/dev/null 2>&1; then
            ACR_USER=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
            ACR_PASS=$(az acr credential show -n "$ACR_NAME" --query 'passwords[0].value' -o tsv)
            kubectl -n "$NS" delete secret acr-pull --ignore-not-found
            kubectl -n "$NS" create secret docker-registry acr-pull \
              --docker-server="$ACR_LOGIN_SERVER" \
              --docker-username="$ACR_USER" \
              --docker-password="$ACR_PASS"
            kubectl -n "$NS" patch serviceaccount default -p '{"imagePullSecrets":[{"name":"acr-pull"}]}' || true
          else
            echo "WARN: ACR admin creds unavailable; relying on AKS–ACR RBAC."
          fi

      - name: Inject backend URLs into frontend/main.js (only if provided)
        if: ${{ inputs.product_api_ip || inputs.order_api_ip || inputs.customer_api_ip }}
        shell: bash
        run: |
          set -Eeuo pipefail
          [[ -n "${PRODUCT_URL:-}"  ]] && sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"     frontend/main.js
          [[ -n "${ORDER_URL:-}"    ]] && sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"         frontend/main.js
          [[ -n "${CUSTOMER_URL:-}" ]] && sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g"   frontend/main.js

      - name: Normalize manifest registry to target ACR
        shell: bash
        env:
          ACR: ${{ env.ACR_LOGIN_SERVER }}
        run: |
          set -Eeuo pipefail
          sed -i -E "s|image:\s*[A-Za-z0-9.-]+\.azurecr\.io/frontend:[^[:space:]]+|image: ${ACR}/frontend:${FRONTEND_TAG}|g" k8s/frontend.yaml || true

      - name: Apply manifest
        shell: bash
        run: |
          kubectl apply -n "$K8S_NAMESPACE_RESOLVED" -f k8s/frontend.yaml

      - name: Set image and restart
        shell: bash
        env:
          NS:  ${{ env.K8S_NAMESPACE_RESOLVED }}
          ACR: ${{ env.ACR_LOGIN_SERVER }}
          TAG: ${{ env.FRONTEND_TAG }}
        run: |
          set -Eeuo pipefail
          kubectl -n "${NS}" set image deploy/${{ env.FRONTEND_DEPLOY }} \
            ${{ env.FRONTEND_CONTAINER }}=${ACR}/frontend:${TAG}
          kubectl -n "${NS}" rollout restart deploy/${{ env.FRONTEND_DEPLOY }}

      # ---- Robust readiness check (handles "old replica pending termination") ----
      - name: Wait for new ReplicaSet Ready (soft check)
        shell: bash
        env:
          NS:  ${{ env.K8S_NAMESPACE_RESOLVED }}
        run: |
          set -Eeuo pipefail
          # Wait up to ~6 min for Ready & Updated replicas
          for i in $(seq 1 72); do
            READY=$(kubectl -n "$NS" get deploy/${{ env.FRONTEND_DEPLOY }} -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo 0)
            UPD=$(kubectl   -n "$NS" get deploy/${{ env.FRONTEND_DEPLOY }} -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo 0)
            DESIRED=$(kubectl -n "$NS" get deploy/${{ env.FRONTEND_DEPLOY }} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo 1)
            echo "Ready=$READY Updated=$UPD Desired=$DESIRED (attempt $i/72)"
            if [[ "${READY:-0}" -ge 1 && "${UPD:-0}" -eq "${DESIRED:-1}" ]]; then
              echo "Frontend deployment is ready."
              exit 0
            fi
            sleep 5
          done
          echo "Timed out waiting for frontend to become ready."
          # Fall through; mark failure so diagnostics run
          exit 1

      - name: Diagnostics on failure
        if: failure()
        shell: bash
        env:
          NS: ${{ env.K8S_NAMESPACE_RESOLVED }}
        run: |
          set -Eeuo pipefail
          echo "---- Pods ----"
          kubectl -n "$NS" get pods -o wide || true
          echo "---- Deploy ----"
          kubectl -n "$NS" describe deploy/${{ env.FRONTEND_DEPLOY }} || true
          echo "---- ReplicaSets ----"
          kubectl -n "$NS" get rs -l app=frontend -o wide || true
          kubectl -n "$NS" describe rs -l app=frontend || true
          POD=$(kubectl -n "$NS" get pods -l app=frontend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [[ -n "$POD" ]]; then
            echo "---- Logs ($POD) ----"
            kubectl -n "$NS" logs "$POD" --all-containers --tail=200 || true
          fi

      - name: Logout Azure
        if: always()
        run: az logout
